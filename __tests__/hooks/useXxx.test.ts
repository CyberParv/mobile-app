import { renderHook, act } from '@testing-library/react-hooks'; import useXxx from '@/hooks/useXxx'; import { mockApi } from '../utils/test-utils'; describe('useXxx Hook', () => { beforeEach(() => { mockApi(); }); it('returns loading=true initially', () => { const { result } = renderHook(() => useXxx()); expect(result.current.loading).toBe(true); }); it('returns data on successful fetch', async () => { const { result, waitForNextUpdate } = renderHook(() => useXxx()); await waitForNextUpdate(); expect(result.current.data).toEqual([{ id: 1, name: 'Item 1' }]); }); it('returns error on failed fetch', async () => { mockApi().get.mockRejectedValueOnce(new Error('Fetch error')); const { result, waitForNextUpdate } = renderHook(() => useXxx()); await waitForNextUpdate(); expect(result.current.error).toBe('Fetch error'); }); it('refetch works after error', async () => { mockApi().get.mockRejectedValueOnce(new Error('Fetch error')); const { result, waitForNextUpdate } = renderHook(() => useXxx()); await waitForNextUpdate(); act(() => { result.current.refetch(); }); await waitForNextUpdate(); expect(result.current.data).toEqual([{ id: 1, name: 'Item 1' }]); }); it('handles empty response', async () => { mockApi().get.mockResolvedValueOnce({ data: [] }); const { result, waitForNextUpdate } = renderHook(() => useXxx()); await waitForNextUpdate(); expect(result.current.data).toEqual([]); }); });